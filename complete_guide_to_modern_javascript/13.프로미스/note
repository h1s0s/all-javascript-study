//자바스크립트는 동기적으로 작동한다.

const data = fetch("api");
console.log('finished');
console.log(data);

//이 예에서는 fetch를 사용하여 어떤 URL을 가져온다.
//동기 코드의 경우에는, fetch 작업이 완료된 후에 다음행이 호출될거라고 예상한다.

//하지만 fetch는 비동기적으로 수행되어 console.log(data)는 undefined를 출력한다.

//이 문제를 해결하기 위해 콜백또는 프로미스를 사용하면 fetch가 무언가를 반환하는 시점까지 기다릴 수 있다.



//콜백 지옥

/* 
비동기 코드를 동기식으로 작동하는 것처럼 하기 위해 콜백으로 여러 코드를 차례로 연결해 작성할 때 발생하는 상황을
콜백지옥이라고 부르기도 한다,

말로 하자면 A를 하고, A가 완료될때까지 기다렸다가 B를 수행하고, B가 완료될떄까지 기다렸다가 C를 하고 이런식이다.
코드도 아주 지저분해짐
*/

const makePizza = (ingredients, callback) => {
    mixIngredients(ingredients, function(mixedIngredients) {
        bakePizza(mixedIngredients, function(bakedPizza) {
            console.log('finished!');
        });
    })
}

/*
* 콜백 지옥이 되어버림, 프로미스를 사용하면 이걸 개선할 수 있다
*/

const myPromise = new Promise((resolve, reject) => {
    resolve("The value we get from the promise");
})

myPromise.then(
    data => {
        console.log(data);
    }
)

/**
 * 프로미스 체이닝
 * 
 * 프로미스의 성공 실패와 무관하게 이전 프로미스에서 반환된것을 후속 프로미스의 기반으로 사용하여 프로미스를 계속 체이닝(연결)할 수 있다
 * 
 */

const myPromise2 = new Promise((resolve, reject) => {
    resolve();
})

myPromise2
    .then(data => {
        return 'working...';
    })
    .then(data => {
        console.log(data);
        throw 'failed!';
    })
    .catch(err => {
        console.error(err);
    })

/**
 * Promise.resolve(), Promise.reject()
 * 
 * 두 함수는 자동으로 성공하거나, 실패하는 프로미스를 생성한다.
 * 
 */

Promise.resolve('Success').then(function(value) {
    console.log('Success');
}, function(value){
    console.log('Fail');
})

Promise.reject(new Error('fail')).then(function(){
    //not called
}, function(error){
    console.log(error);
})

/**
 * Promise.all(), Promise.race()
 * 
 * all()은 모든 프로미스가 성공할 경우에만 성공하는 하나의 프로미스를 반환한다.
 * 
 * race()는 이터러블에 포함된 프로미스들 중 가장 먼저 성공 또는 실패한 결과를 반환한다.
 */

/**
 * 실전 예제: 주문 처리 흐름을 프로미스로 구성하기
 * - 주문 생성 -> 결제 처리 -> 배송 시작 순서로 연결한다.
 * - 중간에 실패하면 catch로 처리한다.
 */

const createOrder = (order) =>
    new Promise((resolve) => {
        setTimeout(() => resolve({ orderId: 1, order }), 300);
    });

const processPayment = (orderInfo) =>
    new Promise((resolve, reject) => {
        const isPaid = true;
        setTimeout(() => {
            if (isPaid) {
                resolve({ ...orderInfo, paid: true });
            } else {
                reject(new Error('결제 실패'));
            }
        }, 300);
    });

const startShipping = (paymentInfo) =>
    new Promise((resolve) => {
        setTimeout(() => resolve({ ...paymentInfo, shipped: true }), 300);
    });

createOrder({ item: '책', quantity: 1 })
    .then(processPayment)
    .then(startShipping)
    .then((result) => {
        console.log('처리 완료:', result);
    })
    .catch((error) => {
        console.error('처리 실패:', error.message);
    });
